---
title: 스크롤 복원, 어떻게 해야 할까?
date: '2025-08-31'
tags: ['Web']
draft: false
summary: React 기반 서비스에서 스크롤 복원에 대해 고민한 내용을 공유합니다.
---

# TL;DR

실제 서비스 개발 과정에서 고민한 **스크롤 복원 전략**을 상황별로 정리했습니다.

- **앱 내 웹뷰(WebView) 구조**: 스크롤 복원 대신 레이어 전환 구조 고려
- **SSR 기반 단순 구조**: 브라우저 기본 scrollRestoration
- **SPA 동일 서비스 라우팅**: React-Query 캐시 활용 (데이터 즉시 복원)
- **복잡한 상태 구조**: sessionStorage 기반 복원
- **데이터 로딩 불규칙**: 목표 Y좌표까지 보정 스크롤
- **긴 무한 스크롤 / 대규모 리스트**: 레이아웃 선점, 스크롤 가상화

---

# 들어가며

커머스 서비스에서 유저는 어떤 경로를 거쳐 구매를 하게 될까요?

커머스 사용자는 베스트 상품, 특가 상품, 다양한 테마로 묶인 기획전이 전시된 페이지에서 상품을 탐색하다 상품 상세 페이지로 이동하고, 다른 상품을 탐색하기 위해 뒤로 가기를 눌러 이전 페이지로 돌아옵니다.

혹은 원하는 상품을 직접 검색해 검색 결과 페이지에서 여러 상품을 살펴본 뒤, 특정 상품을 클릭해 상세 정보를 확인하고 리뷰를 읽다가 다시 뒤로 가기로 돌아와 다른 상품을 탐색하기도 하죠.

이 과정에서 반복되는 유저 행동은 바로 **뒤로 가기를 통한 재탐색**입니다. 만약 사용자가 이전 페이지로 돌아왔을 때, 사용자가 보던 위치가 초기화되어 맨 위로 튀어버린다면 어떨까요? 사용자는 다시 스크롤을 내려가며 본 지점을 찾아야 하고, 이는 곧 탐색 경험의 단절로 이어집니다. 특히 수백 개의 상품이 나열된 긴 페이지에서는 더욱 불편하게 느껴질 수밖에 없습니다.

JSP, PHP 등 서버 렌더링 기반의 전통적인 웹 환경에서는 브라우저가 완성된 HTML을 받아와 렌더링했기 때문에 스크롤 위치도 자연스럽게 복원되었습니다. 하지만 현대 웹 서비스는 초기 HTML만 내려받고 이후 자바스크립트 실행과 API 호출을 통해 화면이 구성되는 구조가 많기 때문에, 브라우저 기본 동작만으로는 원하는 스크롤 복원이 잘 이루어지지 않는 경우가 많습니다.

이에 따라 뒤로가기 액션이 빈번한 커머스 서비스에서의 스크롤 복원은 끊김 없는 사용자에게 탐색 경험을 제공하기 위한 중요한 과제입니다. 이번 글에서는 실제 서비스 개발 과정에서 고민했던 다양한 상황별 스크롤 복원 전략과 구현 방법을 공유해보겠습니다.

# 스크롤 복원이 어려운 이유

## 스크롤 복원 동작의 차이

뒤로가기 시 스크롤 복원은 단순히 Y 좌표를 저장해두었다가 다시 적용하거나, 브라우저의 [BF Cache](https://web.dev/articles/bfcache?hl=ko)를 활용하면 쉽게 해결될 것 같은데요. 실제로는 디바이스마다 캐시 정책이 다르고, 복잡한 렌더링 구조 때문에 복원 시점을 정확히 맞추기 어렵습니다.

특히 웹뷰 기반 서비스에서는 더 까다롭습니다. 브라우저는 히스토리 스택과 BF Cache를 활용해 직전 페이지 상태를 복원하지만, 대부분의 앱 내 WebView는 자체적으로 화면 전환을 관리해 이전 레이어를 다시 노출하는 방식으로 동작합니다.

또한 Cache-Control: no-store가 적용된 페이지는 BF Cache가 동작하지 않아, 뒤로가기를 해도 새로 로딩되며 스크롤 위치 역시 복원되지 않고, 여러 환경에서 테스트하다보면 안드로이드 웹 브라우저는 스크롤이 복원되지 않는 반면, iOS Safari는 스크롤이 정상 복원되는 것을 확인할 수 있습니다. 이는 WebKit 기반 iOS가 BF Cache와 히스토리 복원을 적극적으로 지원하는 반면, 안드로이드는 브라우저마다 정책이 달라 동일한 결과를 보장하지 않기 때문입니다.

이렇듯 각 디바이스 별 스크롤 복원 환경이 다르기 때무에 결국 환경에 맞는 별도의 스크롤 복원 전략이 필요합니다.

## 복잡한 페이지 렌더링 구조

단일 API만 호출하거나, 페이지 전체가 무한 스크롤로 구현된 페이지라면 스크롤 복원은 비교적 단순합니다. 하지만 아래 그림처럼 영역마다 호출하는 API가 다르고, 호출 시점도 제각각이라면 이야기가 달라집니다.

![복잡한 페이지 렌더링 구조](/public/static/images/scroll-restoration/render-area.png)

예를 들어 A, B 영역은 각각 별도의 API 응답에 의존하고, B 영역은 더보기 버튼을 눌러야 확장되며, C 영역은 무한 스크롤로 이어진다고 가정해봅시다. 이 경우 단순히 스크롤 Y 좌표만 저장해서는 원하는 복원 결과를 얻을 수 없습니다.

- A, B 영역의 데이터 상태
- 더보기 영역의 page 번호와 노출된 아이템 수
- 무한 스크롤 영역의 page 번호와 로드된 데이터

이 모든 상태를 함께 관리해야 하고, 스크롤을 복원하는 순간에 각 영역의 로딩 순서와 시점이 정확히 맞아야 합니다. 결국 이런 구조에서는 작은 실수에도 사이드 이펙트가 생기기 쉽고, 안정적으로 스크롤을 복원하기가 매우 까다로워집니다.

# 스크롤 복원 여러 전략

동일 서비스 내에서 라우팅되는 페이지라면 React Query 캐싱이나 Next.js의 scrollRestoration 같은 기본 기능을 활용할 수 있으나, 서로 다른 서비스 간 이동에서는 이 방식이 어렵습니다.

예를 들어 검색 서비스와 상품 상세 서비스가 서로 다른 서비스로 분리되어 개발된 구조라면, React Query 캐시는 범위를 벗어나고 Next.js의 scrollRestoration도 라우터 히스토리가 단절되기 때문에 정상적으로 동작하지 않습니다.  
결국 뒤로가기를 해도 브라우저가 새 페이지를 로딩하게 되고, 스크롤은 초기화됩니다.

이번 파트에서는 이러한 서비스 간 이동 상황에서의 스크롤 복원 문제와 여러 해결 전략을 다루겠습니다.

## 상태 기반 복원 전략

### 브라우저 기본 기능 활용하기

브라우저에서는 [`history.scrollRestoration`](https://developer.mozilla.org/ko/docs/Web/API/History/scrollRestoration) 속성을 제공해 뒤로가기 시 스크롤 위치를 자동으로 복원할 수 있습니다.  
이 속성이 `'auto'`로 설정되어 있으면 브라우저가 스크롤 복원을 알아서 처리하고, `'manual'`로 설정하면 직접 제어할 수 있습니다.

```javascript
// 브라우저 기본 스크롤 복원 활성화
if ('scrollRestoration' in history) {
  history.scrollRestoration = 'auto'
}
```

단, SPA 환경에서는 데이터 로딩 시점과 화면 갱신 방식이 브라우저 기본 동작과 달라 스크롤 복원이 제대로 동작하지 않는 경우가 있어, 별도의 처리가 필요하게 됩니다.

| 장점                       | 단점                                          |
| -------------------------- | --------------------------------------------- |
| 별도 복원 로직이 필요 없음 | 모든 디바이스·환경에서 동일하게 동작하지 않음 |

### 웹 스토리지에 상태 저장하기

스냅샷을 찍듯이 스크롤 복원에 필요한 모든 상태를 웹 스토리지에 저장하는 방식입니다.
세션(탭) 단위에서 유지하기 위해 `sessionStorage`에 스크롤 Y 좌표와 데이터를 함께 저장해두었다가 뒤로가기로 돌아왔을 때 복원합니다.
구현은 간단하지만 데이터 동기화 타이밍 관리가 중요하며, 웹 스토리지는 브라우저마다 약 5MB 내외의 용량 제한이 있으므로
`Blob` 을 활용해 저장 전 저장 용량을 미리 측정하는 것이 안전합니다.

```js
const LIMIT = 5 * 1024 * 1024 // 약 5MB
const STORAGE_KEY = 'search-snapshot'

// 스냅샷 저장 (데이터 + 스크롤 위치)
function saveSnapshot(data) {
  const snapshot = {
    scrollY: window.scrollY,
    data, // 예: API 응답 결과, 리스트 아이템 등
    timestamp: Date.now(),
  }

  const payload = JSON.stringify(snapshot)
  const bytes = new Blob([payload]).size

  if (bytes < LIMIT) {
    sessionStorage.setItem(STORAGE_KEY, payload)
  }
  //...
}
```

| 장점                                                  | 단점                           |
| ----------------------------------------------------- | ------------------------------ |
| API 재호출 없이 기존 데이터를 활용해 빠르게 복원 가능 | 웹 스토리지 용량에 제한이 있음 |

## 스크롤 보정 기반 복원 전략

### 목표 Y 좌표까지 반복 스크롤하기

스크롤 복원을 위해 필요한 상태를 모두 관리하기 어렵다면, 목표 Y 좌표에 도달할 때까지 반복해서 스크롤을 시도하는 방법을 고려해볼 수 있습니다.
단, scrollTo를 단순 반복하면 화면이 미세하게 튀거나 버벅이는 느낌을 줄 수 있기 때문에,
[requestAnimationFrame(rAF)](https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame)을 활용해 프레임 단위로 보정하면 훨씬 자연스럽게 동작합니다.

또한 네트워크 지연으로 데이터 로딩이 늦어질 수도 있으므로, 최대 스크롤 시도 시간을 제한해 두는 것이 안전합니다.

```js
function restoreScroll(targetY) {
  const start = performance.now()
  const DURATION = 1000 // 예) 스크롤 시간을 1초로 제한

  function scrollToTarget() {
    if (window.scrollY >= targetY) return

    const maxScroll = document.documentElement.scrollHeight - window.innerHeight // 현재 페이지에서 도달할 수 있는 가장 아래쪽 스크롤 Y 좌표

    if (targetY <= maxScroll) {
      window.scrollTo(0, targetY)
      return
    }

    if (performance.now() - start < DURATION) {
      requestAnimationFrame(scrollToTarget)
    }
  }

  requestAnimationFrame(scrollToTarget)
}
```

| 장점                                                                                         | 단점                                                                                                                                                                |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 구현이 단순하고 직관적이며, 중간 구간이 순차적으로 로드되므로 **결국 목표 위치에 도달 가능** | **필요한 모든 중간 구간 API**를 호출해야 해서 네트워크, 렌더링 지연 발생, 응답 속도에 따라 반복 호출 횟수가 늘어나므로 시간 제한, 최대 재시도 같은 제어 장치가 필요 |

## 렌더링 기반 복원 전략

### 레이아웃 선점

무한 스크롤 페이지에서 스크롤 위치를 저장해두었다가 뒤로가기로 돌아오면, 단순히 scrollY 값을 복원하는 것만으로는 원하는 위치에 도달하기 어렵습니다.
그 이유는 저장 당시의 문서 전체 높이(scrollHeight)와 뒤로가기로 돌아왔을 때 초기 로딩 상태의 높이가 다르기 때문인데요.

![문서 전체 높이의 차이](/public/static/images/scroll-restoration/scroll-diff.png)

예를 들어, 3페이지 분량까지 로드된 상태에서 스크롤 위치를 저장했더라도, 뒤로가기로 돌아왔을 때는 1페이지 분량만 렌더링돼 있으니 scrollTo(savedY)를 호출해도 해당 좌표까지는 도달할 수 없습니다.

이 문제를 해결하려면 이전 레이아웃 높이를 페이지 전환 시점에 세션스토리지 등에 저장하고, 복원 시 세션스토리지에 기록된 높이 정보를 읽어와, 최대 높이에 해당하는 스켈레톤을 먼저 그려 전체 레이아웃을 선점합니다.
그 뒤에 뷰포트 주변부터 실제 데이터를 불러와 교체하면, 스크롤 위치를 안정적으로 맞출 수 있습니다.

뷰포트 주변 먼저 API를 요청을 하고 스크롤 이동에 따라 다음 API를 호출하는 방식을 구현하는 방식은 매우 복잡하나, 구현 순서를 단순화하면 아래와 같습니다.

1.  페이지 전환 시점에 현재까지 로드된 전체 높이(scrollHeight)를 세션스토리지 등에 저장한다.
2.  뒤로가기 복원 시점에 저장된 scrollHeight를 읽어와, 해당 높이에 맞는 스켈레톤을 먼저 렌더링한다.
3.  뷰포트 주변 아이템에 해당하는 API를 우선 호출하여 실제 데이터를 불러온다.
4.  이후 사용자가 스크롤을 이동할 때마다 해당 위치에 필요한 API를 순차적으로 호출하고, 스켈레톤을 실제 데이터로 교체한다.
5.  모든 영역이 실제 데이터로 채워지면 스크롤 위치 복원이 마무리된다.

    | 장점                                                                 | 단점                                                         |
    | -------------------------------------------------------------------- | ------------------------------------------------------------ |
    | 저장한 scrollHeight로 전체 높이를 먼저 확보해 스크롤 복원이 안정적임 | 스켈레톤 노출, 비노출 로직 구현 필요                         |
    | 뷰포트 주변만 실제 데이터를 불러오면 초기 로딩 비용을 줄일 수 있음   | 뷰포트 기준으로 API를 순차적으로 호출,교체하는 로직이 복잡함 |

### 스크롤 가상화

앞서 본 레이아웃 선점은 정확한 복원에 유리하지만 구현 난이도가 높은 편입니다.
긴 목록을 가진 페이지에서는 성능 최적화를 위해 스크롤 가상화(virtualization)를 고려해볼 수 있을텐데요. 스크롤 가상화 적용한다면 성능 최적화와 스크롤 복원을 동시에 해결할 수 있습니다.

가상화 라이브러리(예: react-window, react-virtualized)는 리스트를 감싸는 컨테이너(container) 안에 spacer(더미 박스)를 두어 전체 높이(totalHeight)를 먼저 확보합니다.
이 spacer 덕분에 브라우저는 전체 데이터가 있는 것처럼 스크롤바를 계산하고, 사용자는 전체 영역을 탐색할 수 있습니다.

그다음 실제 DOM에는 뷰포트 근처 몇 개 아이템만 렌더링되는데, 이때 핵심 원리는 스크롤 위치(scrollTop)과 아이템 인덱스(index)간의 매핑입니다.

- 고정 높이 아이템: scrollTop ÷ itemHeight = index로 단순 계산
- 가변 높이 아이템: 각 아이템 높이를 측정, 캐싱해 누적합으로 매핑

![스크롤 가상화 다이어그램](/public/static/images/scroll-restoration/virtualized-scroll.png)

이 방식 덕분에 스크롤 복원도 단순해집니다. 저장해둔 scrollTop만 그대로 복원하면, 해당 인덱스를 계산해 올바른 아이템을 뷰포트에 그릴 수 있기 때문입니다.

다만 이 경우 컨테이너와 spacer는 CSS 기반으로 구현되므로, 기존 서비스에 라이브러리를 그대로 적용하면 레이아웃이 깨질 수 있습니다.  
실무에서는 서비스의 CSS 구조에 맞춰 **적절히 커스터마이징**하거나 자체 구현을 고려해야 합니다.

# 마치며

이번 글에서는 브라우저의 기본 기능부터, 상태 기반 복원 그리고 렌더링 기반 복원까지 여러 전략을 살펴보았습니다. 각 방식은 장단점이 뚜렷하고, 서비스 구조나 요구사항에 따라 적용 가능성이 달라집니다.

결국 중요한 것은 사용자 경험(UX)이니 단일 정답을 찾기보다는, 서비스 특성에 맞는 전략을 수립하는게 중요하다는 걸 배울 수 있었습니다. 이번 글이 비슷한 문제를 마주한 분들에게 작은 참고가 되길 바랍니다.
