---
title: Next.js SSR 인프라 초기 설계편
date: '2025-03-16'
tags: ['infra']
draft: false
summary: Next.js 도입을 위한 인프라 설계 과정에서 학습한 내용을 정리합니다.
---

# 들어가며

최근 Next.js로의 전환을 위한 초기 셋팅을 진행하며 배포 CI/CD 파이프라인과 프론트엔드 서버 인프라 설계에 도전했는데요. 인프라, 서버를 다룬 경험이 적다보니 Next.js를 도입할 때 가장 걱정이 되었던 부분이기도 했습니다.

물론 회사 내에 인프라 구성에 도움을 주시는 분들이 계시지만, 각 서버를 운영하는 것은 팀의 소관이었기 때문에 운영에 필요한 지식을 공부하는 것이 선행되어야 했습니다. 그래서 이번 글에서는 기존 서버 구조부터 Next.js 기반 구조, 그리고 AWS 환경에서의 구성 예시까지 함께 정리해보려고 합니다.

## 왜 Next.js 도입이 필요했나?

현재 운영 중인 서비스는 JSP 기반에서 Next.js로 전환을 진행하고 있습니다. 과거 JSP 기반 구조에서 React로 마이그레이션이 이뤄지면서 JSP에서 React 애플리케이션의 자바스크립트 번들 파일을 불러와 화면을 렌더링하는 구조로 동작하고 있었습니다.

이 구조에서는 첫 렌더링에서 'API 요청을 인한 지연'을 줄이는 방법을 통해 LCP를 N초 단축시켰습니다. 즉, 첫 렌더링을 빠르게 하기 위해, 첫 로딩 시 JSP에서 API를 호출해 필요한 초기 데이터를 받아오고, 그 데이터를 window 객체에 담아 React 앱이 별도 API 호출 없이 바로 렌더링하는 구조였습니다. 어떻게 보면 나름 반쪽짜리 SSR이라고 볼 수 있겠네요.

하지만 이후 JSP 내에 존재했던 백엔드 로직이 분리되었음에도 프론트는 여전히 JSP 위에서 구동하고 있었습니다. 이로 인해 배포시간이 불필요하게 길어졌고, JSP 내 import 되는 자바스크립트 파일명이 항상 고정되어야 하다보니, React 빌드를 할때마다 생성되는 유니크한 해쉬값을 사용할 수 없었습니다.

그 결과, 이전 버전의 해시값을 알 수 없어
파이프라인을 통한 롤백 구조를 갖추기 어려워, 장애 대응이나 긴급 롤백 시에는 결국 재배포 외에 방법이 없었습니다. 또한 JSP 구조를 운영하기 위해 서버 자원이 불필요하게 낭비되기도 했죠.

결국 SSR을 통한 빠른 렌더링, 안정적인 롤백 구조 구축, SEO 강화를 위해 Next.js로의 전환을 시작했습니다.

# CSR과 다른 SSR 구조 이해하기

## Next.js SSR 구조, 왜 이해해야 할까?

React 기반의 CSR(Client Side Rendering)을 적용한 서비스는 npm run build를 통해 번들 파일을 빌드하고, html, 빌드파일 등 CSR에 필요한 정적 파일을 웹서버에 올려, 브라우저에 전달하는 방식으로 구성됩니다.

![CSR 인프라 구성 예시](/static/images/nextjs-ssr-infrastructure/asis-infra.png)

Next.js에서 SSR(Server Side Rendering)을 도입하면, 기존에 React 빌드 파일을 제공하게되면 정적 배포 방식과 달리, 서버가 HTML을 그려 내려주는 역할이 필요할텐데요.

SSR은 React 앱을 서버에서 실행해 HTML을 생성하는 작업이기 때문에, Node.js 환경이 필요합니다. 그래서 일반적인 정적 웹서버에서는 SSR을 처리할 수 없고, 별도로 SSR을 담당하는 서버를 구성하는 것이 일반적입니다.

물론 하나의 서버에 nginx와 Node.js 기반 SSR 애플리케이션을 함께 올리는 방식도 가능합니다. 이런 구조는 초기에는 설정이 간단하고 배포도 편리해서 소규모 프로젝트에서 주로 사용됩니다.

다만 실무에서는 정적 자산을 서빙하는 nginx와 SSR을 수행하는 Node.js 서버를 분리하는 방식을 더 많이 채택합니다. 이유는 다음과 같습니다.

- 리소스 분리: SSR은 CPU를 많이 사용하고, nginx는 네트워크/디스크 IO에 특화되어 있어 리소스 충돌이 발생할 수 있음
- 장애 격리: SSR 프로세스가 죽더라도 nginx는 살아 있을 수 있어 서비스 전체 중단을 막을 수 있음
- 유연한 스케일 전략: nginx는 고정시키고, SSR 서버만 독립적으로 scale-out 가능
- 보안성 강화: nginx는 외부 노출, SSR 서버는 내부에서만 접근 가능하도록 구성 가능
- 운영 단순화: 정적 요청은 CDN 또는 nginx에서 처리, SSR은 전용 서버가 담당하니 로직이 명확해짐

이처럼 구조가 복잡해지더라도 역할을 분리해두면 트래픽 급증, 장애 대응, 배포 전략 등에서 유리한 점이 많아 Next.js SSR을 도입하는 대부분의 서비스에서는 이러한 구조를 가져가는데요. 이제 실제로 SSR 구조에서 어떤 인프라 구성이 필요한지 살펴보겠습니다.

## Next.js 인프라는 어떻게 구성할까?

Next.js는 SSR, ISR, SSG 등 다양한 렌더링 방식을 지원합니다.
이 중 SSR과 ISR처럼 HTML을 동적으로 생성하는 경우에는,단순한 정적 웹서버만으로는 대응이 어려워 별도의 서버 구성이나 런타임 환경이 필요합니다.

우선 사용자에게 페이지가 렌더링되기 까지의 구조를 간단하게 정리해보겠습니다. 실제 운영 환경에서는 정적 자산을 서빙하는 nginx와 HTML을 렌더링하는 Node.js SSR 서버를 역할에 따라 분리해 다음과 같이 구성할 수 있습니다.
![Next.js 인프라 구성 예시](/static/images/nextjs-ssr-infrastructure/next-infra-1.png)

사용자가 서비스에 접속하면, 브라우저의 요청은 L4 로드밸런서를 거쳐 IP/PORT 기준으로 각 웹서버에 분산됩니다.  
웹서버에서는 nginx가 동작하며, 정적 파일을 직접 서빙하거나 SSR 요청을 Node.js 서버로 프록시합니다.

이때 nginx는 upstream 설정에 따라 여러 Node.js SSR 서버에게 트래픽을 `라운드 로빈 방식(Round Robin)`으로 분산하게 됩니다.
![라운드 로빈](https://i0.wp.com/nginxstore.com/wp-content/uploads/2023/04/image-14.png?w=685&ssl=1)
참고: [NGINX 로드 밸런싱 알고리즘 작동 원리](https://nginxstore.com/blog/nginx/nginx-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC/)

라운드 로빈(Round Robin)은 NGINX에서 사용되는 기본(Default) 로드 밸런싱 알고리즘인데요. 위 사진에서 가이드는 각 대기열을 순서대로 선택합니다. 첫 번째 여행자는 대기열 A로 안내되고, 다음 여행자는 대기열 B로 안내되는 식의 방식으로 트래픽을 분산합니다.

그럼 Node.js 서버에서는 Next.js가 어떻게 구동되고 있을까요? 만약 배포가 이루어질 때마다 Next.js 서버를 직접 종료하고 다시 실행한다면, 그 사이 사용자에게는 오류 페이지나 빈 화면이 노출될 수 있습니다.

이러한 문제를 막기 위해서는 서비스를 중단 없이, 즉 무중단 배포 방식으로 운영할 수 있는 구조가 필요합니다. 이때 사용하는 프로세스 매니저가 바로 pm2입니다.
![pm2 클러스터](https://ryanschiang.com/_next/image?url=%2Fimages%2Fpm2-cluster-zero-downtime.jpg&w=1920&q=75)

참고: [How to Use PM2 Clusters with NodeJS for Zero Downtime Deployment](https://ryanschiang.com/pm2-cluster-zero-downtime)

pm2는 Node.js 애플리케이션의 프로세스를 관리해주는 툴인데요. 단순히 앱을 실행하는 데 그치지 않고, 장애 발생 시 자동 재시작, 로그 관리, 메모리/CPU 모니터링, 그리고 가장 중요한 `클러스터 모드(cluster mode)`까지 지원합니다.

클러스터 모드는 하나의 Node.js 서버(예: 포트 3000)를 기준으로, 내부적으로 여러 개의 워커 프로세스를 생성해 요청을 병렬로 처리할 수 있도록 합니다.
마스터 프로세스가 클라이언트 요청을 받아,각 워커 프로세스로 라운드로빈 방식으로 분산 처리합니다.

pm2로 무중단 배포까지 적용하여 다음과 같은 구조로 구성해봤습니다.

![Next.js 인프라 구성 예시 pm2](/static/images/nextjs-ssr-infrastructure/next-infra-2.png)

정리해보자면, Next.js의 SSR을 안정적으로 운영하기 위해서는 정적 자산 서빙하는 서버와 SSR 요청을 처리하는 서버를 분리하고, pm2를 활용한 클러스터 구성으로 무중단 배포와 병렬 처리까지 고려한 인프라 설계가 필요합니다.

지금까지 소개한 인프라 구성은 IDC나 사내 물리 서버 기반 환경에서 적용해볼 수 있는 예시인데요, 그렇다면 이를 AWS 같은 클라우드 환경에서는 어떻게 구성할 수 있을지 간단하게 살펴보겠습니다.

# AWS 환경에서는 어떻게 구성할까?

AWS에서도 앞서 확인한 SSR 인프라 구조와 유사하게, 정적 자산과 SSR 서버를 분리하여 구성할 수 있습니다.
![Next.js 인프라 구성 예시 pm2](/static/images/nextjs-ssr-infrastructure/nextjs-aws.png)

- 정적 자산(public, .next/static 등)은 S3 + CloudFront를 통해 캐싱 및 전송 속도를 최적화할 수 있고,
- SSR 요청은`Application Load Balancer(ALB)`를 통해 트래픽을 분산한 뒤,
- EC2 인스턴스에서 Next.js 앱을 실행하여 응답을 생성합니다.

이때, EC2 내부에서는 기존과 마찬가지로 pm2를 활용해 여러 인스턴스를 클러스터 모드로 실행할 수 있습니다.
pm2를 사용하면 AWS 환경에서도 무중단 배포가 가능하며, 클라이언트 요청은 마스터 프로세스가 받아 각 워커로 라운드로빈 방식으로 분산됩니다.

즉, 클라우드로 전환되었을 뿐 핵심 구성 방식은 그대로 가져가되, 정적 자산을 더 빠르고 효율적으로 전달하고, SSR 서버의 탄력적인 운영이 가능하다는 차이점이 있습니다.

더 나아가, Docker 기반으로 애플리케이션을 컨테이너화한 뒤, 이를 ECS(EC2 또는 Fargate) 같은 AWS의 컨테이너 오케스트레이션 서비스에 배포하는 방식도 있습니다.
이 방식은 서버를 직접 관리하지 않아도 되고, 오토 스케일링, 롤링 배포, 장애 복구 등 인프라 운영을 자동화할 수 있다는 장점이 있습니다. 다만, 초기 설정과 도커 이미지 관리 등 DevOps에 대한 이해가 필요하므로, 팀의 규모나 기술 스택, 자동화 필요성에 따라 선택적으로 고려할 수 있습니다.

# 마치며

지금까지 IDC 환경에서의 SSR 인프라 구성부터, AWS 환경에서 어떻게 구성할 수 있을지까지 간단히 정리해봤습니다.
아직 익숙하진 않지만, 이번 기회에 공부한 내용을 정리하면서 인프라 구조에 대한 감이 조금씩 잡혀가는 느낌이 들었습니다.
앞으로 실제 인프라 운영 경험이 쌓이면, 그 이야기도 따로 정리해보겠습니다. 이 글이 저처럼 SSR이나 인프라 구성을 처음 접하는 분들께 도움이 되었으면 좋겠네요!
